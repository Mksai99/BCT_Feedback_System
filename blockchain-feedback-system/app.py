from flask import Flask, render_template, request, redirect, session, url_for
from datetime import datetime
from pymongo import MongoClient
from bson.objectid import ObjectId
import hashlib
import json

app = Flask(__name__)
app.secret_key = "any_random_long_secret_here"

# ---------- MongoDB ----------
MONGO_URI = "mongodb://localhost:27017/"
client = MongoClient(MONGO_URI)
db = client["feedback_blockchain_db"]

# Separate collections for each role
students_col = db["students"]     # {username, password, role="student"}
faculty_col = db["faculty"]       # {username, password, role="faculty"}
admins_col = db["admins"]         # {username, password, role="admin"}

feedback_col = db["feedback"]     # feedback documents
blocks_col = db["blocks"]         # blockchain

# secret salt for student anonymity
ANON_SALT = "some_fixed_random_salt"


# ---------- Helpers ----------
def sha256(text: str) -> str:
    return hashlib.sha256(text.encode("utf-8")).hexdigest()


def create_default_admin():
    """Create default admin user if none exists in admins collection."""
    if admins_col.count_documents({"role": "admin"}) == 0:
        admins_col.insert_one({
            "username": "admin",
            "password": "admin123",  # demo only
            "role": "admin"
        })


def get_last_block():
    last_block = blocks_col.find_one(sort=[("idx", -1)])
    if last_block:
        return {"idx": last_block["idx"], "hash": last_block["hash"]}
    return None


def create_block(feedback_id: ObjectId, feedback_data: dict):
    data_json = json.dumps(feedback_data, sort_keys=True)
    data_hash = sha256(data_json)

    last = get_last_block()
    if last:
        idx = last["idx"] + 1
        prev_hash = last["hash"]
    else:
        idx = 0
        prev_hash = "0"

    timestamp = datetime.utcnow().isoformat()
    block_string = f"{idx}{timestamp}{data_hash}{prev_hash}"
    block_hash = sha256(block_string)

    blocks_col.insert_one({
        "idx": idx,
        "feedback_id": feedback_id,
        "timestamp": timestamp,
        "data_hash": data_hash,
        "prev_hash": prev_hash,
        "hash": block_hash
    })


def verify_chain() -> bool:
    blocks = list(blocks_col.find().sort("idx", 1))
    prev_hash = "0"
    for b in blocks:
        idx = b["idx"]
        timestamp = b["timestamp"]
        data_hash = b["data_hash"]
        stored_prev = b["prev_hash"]
        stored_hash = b["hash"]

        if stored_prev != prev_hash:
            return False

        calc_hash = sha256(f"{idx}{timestamp}{data_hash}{stored_prev}")
        if calc_hash != stored_hash:
            return False

        prev_hash = stored_hash
    return True


def current_user():
    if "username" in session:
        return {
            "username": session["username"],
            "role": session["role"]
        }
    return None


def login_required(role=None):
    def decorator(fn):
        def wrapper(*args, **kwargs):
            user = current_user()
            if not user:
                return redirect(url_for("login"))
            if role and user["role"] != role:
                return "Unauthorized", 403
            return fn(*args, **kwargs)
        wrapper.__name__ = fn.__name__
        return wrapper
    return decorator


# ---------- Routes ----------

@app.route("/")
def home():
    return render_template(
        "home.html",
        title="Secure Feedback System",
        heading="Secure Feedback System",
    )


@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        role = request.form.get("role")

        # choose collection based on role
        if role == "student":
            col = students_col
        elif role == "faculty":
            col = faculty_col
        elif role == "admin":
            col = admins_col
        else:
            col = None

        user = None
        if col is not None:
            user = col.find_one({"username": username, "password": password, "role": role})

        if user:
            session["username"] = username
            session["role"] = role
            if role == "student":
                return redirect(url_for("student_feedback"))
            elif role == "faculty":
                return redirect(url_for("faculty_feedbacks"))
            else:
                return redirect(url_for("admin_dashboard"))
        else:
            return render_template(
                "login.html",
                error="Invalid credentials",
                title="Login",
                heading="Login",
            )

    return render_template("login.html", error=None, title="Login", heading="Login")


@app.route("/logout")
def logout():
    session.clear()
    return redirect(url_for("login"))


# ----- Student -----
@app.route("/student/feedback", methods=["GET", "POST"])
@login_required(role="student")
def student_feedback():
    if request.method == "POST":
        faculty_username = request.form.get("faculty_username")
        course = request.form.get("course")
        comments = request.form.get("comments")
        created_at = datetime.utcnow().isoformat()

        # 4 criteria ratings (1–5)
        rating_knowledge = int(request.form.get("rating_knowledge"))
        rating_communication = int(request.form.get("rating_communication"))
        rating_punctuality = int(request.form.get("rating_punctuality"))
        rating_support = int(request.form.get("rating_support"))

        avg_rating = round(
            (rating_knowledge
             + rating_communication
             + rating_punctuality
             + rating_support) / 4.0,
            2,
        )

        student_username = session["username"]
        # anonymized student id (not shown anywhere)
        student_hash = sha256(student_username + ANON_SALT)

        fb_doc = {
            "faculty_username": faculty_username,
            "course": course,
            "comments": comments,
            "created_at": created_at,
            "student_hash": student_hash,
            "ratings": {
                "knowledge": rating_knowledge,
                "communication": rating_communication,
                "punctuality": rating_punctuality,
                "support": rating_support,
            },
            "average_rating": avg_rating,
            "deleted": False,   # for soft delete
        }

        result = feedback_col.insert_one(fb_doc)
        fb_id = result.inserted_id

        # data used on blockchain (still anonymous)
        fb_for_chain = {
            "id": str(fb_id),
            "faculty_username": faculty_username,
            "course": course,
            "comments": comments,
            "created_at": created_at,
            "student_hash": student_hash,
            "ratings": fb_doc["ratings"],
            "average_rating": avg_rating,
        }
        create_block(fb_id, fb_for_chain)

        return redirect(url_for("student_feedback"))

    # GET – show form with faculty list
    faculty_list = list(
        faculty_col.find({"role": "faculty"}, {"username": 1, "_id": 0})
    )
    return render_template(
        "student_feedback.html",
        faculty_list=faculty_list,
        title="Student Feedback",
        heading="Student Panel",
    )


# ----- Faculty -----
@app.route("/faculty/feedbacks")
@login_required(role="faculty")
def faculty_feedbacks():
    faculty_username = session["username"]
    fbs = list(
        feedback_col.find({
            "faculty_username": faculty_username,
            "deleted": {"$ne": True}
        }).sort("created_at", -1)
    )

    feedbacks = []
    for fb in fbs:
        ratings = fb.get("ratings", {})
        feedbacks.append(
            {
                "course": fb.get("course"),
                "comments": fb.get("comments"),
                "created_at": fb.get("created_at"),
                "avg": fb.get("average_rating", 0),
                "knowledge": ratings.get("knowledge", "-"),
                "communication": ratings.get("communication", "-"),
                "punctuality": ratings.get("punctuality", "-"),
                "support": ratings.get("support", "-"),
            }
        )

    return render_template(
        "faculty_feedbacks.html",
        feedbacks=feedbacks,
        title="Faculty Feedbacks",
        heading="Faculty Panel",
    )


# ----- Admin -----
@app.route("/admin")
@login_required(role="admin")
def admin_dashboard():
    faculty_list = list(faculty_col.find({"role": "faculty"}, {"username": 1, "_id": 0}))
    fbs = list(
        feedback_col.find({
            "deleted": {"$ne": True}
        }).sort("created_at", -1)
    )

    feedbacks = []
    for fb in fbs:
        ratings = fb.get("ratings", {})
        feedbacks.append(
            {
                "id": str(fb["_id"]),
                "faculty_username": fb.get("faculty_username"),
                "course": fb.get("course"),
                "comments": fb.get("comments"),
                "created_at": fb.get("created_at"),
                "avg": fb.get("average_rating", 0),
                "knowledge": ratings.get("knowledge", "-"),
                "communication": ratings.get("communication", "-"),
                "punctuality": ratings.get("punctuality", "-"),
                "support": ratings.get("support", "-"),
            }
        )

    chain_valid = verify_chain()
    return render_template(
        "admin_dashboard.html",
        faculty_list=faculty_list,
        feedbacks=feedbacks,
        chain_valid=chain_valid,
        title="Admin Dashboard",
        heading="Admin Panel",
    )


@app.route("/admin/add-faculty", methods=["POST"])
@login_required(role="admin")
def admin_add_faculty():
    username = request.form.get("username")
    password = request.form.get("password")
    if username and password:
        faculty_col.insert_one({"username": username, "password": password, "role": "faculty"})
    return redirect(url_for("admin_dashboard"))


@app.route("/admin/add-student", methods=["POST"])
@login_required(role="admin")
def admin_add_student():
    username = request.form.get("username")
    password = request.form.get("password")
    if username and password:
        students_col.insert_one({"username": username, "password": password, "role": "student"})
    return redirect(url_for("admin_dashboard"))


@app.route("/admin/delete-faculty/<username>", methods=["POST"])
@login_required(role="admin")
def admin_delete_faculty(username):
    # Only delete users who are actually faculty
    faculty_col.delete_one({"username": username, "role": "faculty"})
    return redirect(url_for("admin_dashboard"))


@app.route("/admin/delete-feedback/<feedback_id>", methods=["POST"])
@login_required(role="admin")
def admin_delete_feedback(feedback_id):
    """
    Soft delete feedback: mark as deleted = True, keep it in DB + blockchain.
    This keeps blockchain history intact but hides it from UI.
    """
    try:
        fid = ObjectId(feedback_id)
    except Exception:
        return redirect(url_for("admin_dashboard"))

    feedback_col.update_one(
        {"_id": fid},
        {"$set": {"deleted": True, "deleted_at": datetime.utcnow().isoformat()}}
    )
    return redirect(url_for("admin_dashboard"))


# ---------- Main ----------
if __name__ == "__main__":
    create_default_admin()
    app.run(debug=True)
